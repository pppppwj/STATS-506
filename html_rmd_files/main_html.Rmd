---
title: "STATS 506 - Group Project"
author: "Group 1 - Weijie Pan, Jingxian Chen, Eric Hernandez-Montenegro"
date: "12/9/2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(SASxport)
library(tidyverse)
library(doParallel)
library(glmnet)
library(ROCit)
```

# Introduction

# Data

# Methods

# Core Analysis {.tabset .tabset-fade .tabset-pills}

## R

### Load data
```{r load_data}
Demographic_data <- read.xport("C:\\Users\\95260\\Desktop\\stats506\\group_project\\DEMO_I.XPT")
Diabetes_data <- read.xport("C:\\Users\\95260\\Desktop\\stats506\\group_project\\DIQ_I.XPT")
Day1_data <- read.xport("C:\\Users\\95260\\Desktop\\stats506\\group_project\\DR1TOT_I.XPT")
Day2_data <- read.xport("C:\\Users\\95260\\Desktop\\stats506\\group_project\\DR2TOT_I.XPT")
Insurance_data <- read.xport("C:\\Users\\95260\\Desktop\\stats506\\group_project\\HIQ_I.XPT")
```

---

### Data Cleaning
For the data cleaning part , I decide to use the dplyr package to help me solve it.
```{r data_clean}
# Demographic data
New_Demo_dat <-  Demographic_data %>%
                    select("id" = SEQN, 
                            "gender" = RIAGENDR, 
                            "age" = RIDAGEYR,
                            "income" = INDFMIN2) %>%
                    filter(!is.na(income) & income != 12 & income != 13 
                           & income != 77 & income != 99) %>%
                    transmute(id = id,
                              gender = factor(gender, labels =c("male","female")),
                              age_group = factor(ifelse(age < 13, 1, 
                                                        ifelse(age < 19,2,
                                                        ifelse(age < 41, 3,
                                                        ifelse(age < 60, 4, 5)))),
                                                 labels = c("younger", "teenager",
                                                            "adult", "seniors", "elder")),
                              income = factor(ifelse(income == 14 | income ==15, income - 2,
                                              income)))

# Insurance data
# remove values other than 1 or 2 and divide insurance variable into 2 columns
New_Insur_dat <- Insurance_data %>%
                    select("id" = SEQN, "insurance" = HIQ011) %>%
                    filter(insurance != 7 & insurance != 9) %>%
                    transmute(id = id,
                              insurance = ifelse(insurance == 1, 1, 0))

# diabetes data
# remove values other than 1 or 2, and change 2 to 0
New_Diabetes_dat <- Diabetes_data %>%
                        select("id" = SEQN, "diabetes" = DIQ010)%>%
                        filter(!is.na(diabetes) & diabetes != 3 & diabetes != 9) %>%
                        transmute(id = id,
                                  diabetes = ifelse(diabetes == 2, 0, 1))

## Day1 data
New_Day1_dat <- Day1_data %>%
                    select("id" = SEQN, "weight" = WTDRD1, "iron" = DR1TIRON,
                           "calcium" = DR1TCALC, "zinc" = DR1TZINC, "sodium" = DR1TSODI,
                           "VE" = DR1TATOC, "VA" = DR1TVARA, "VC" = DR1TVC,
                           "alcohol" = DR1TALCO, "fat" = DR1TTFAT, "fiber" = DR1TFIBE,
                           "sugar" = DR1TSUGR, "carbonhydrate" = DR1TCARB,
                           "energy" = DR1TKCAL, "protein" = DR1TPROT) %>%
                    filter(weight != 0) %>%
                    filter_at(vars(-c("id", "weight")), all_vars(!is.na(.))) %>%
                    # for data visualization part, we don't standaardize the variables
                    mutate_at(vars(-c("id", "weight")), scale)  %>%
                    mutate(survey_day = factor(1))

# Day2 data
New_Day2_dat <- Day2_data %>%
                    select("id" = SEQN, "weight" = WTDR2D, "iron" = DR2TIRON,
                           "calcium" = DR2TCALC, "zinc" = DR2TZINC, "sodium" = DR2TSODI,
                           "VE" = DR2TATOC, "VA" = DR2TVARA, "VC" = DR2TVC,
                           "alcohol" = DR2TALCO, "fat" = DR2TTFAT, "fiber" = DR2TFIBE,
                           "sugar" = DR2TSUGR, "carbonhydrate" = DR2TCARB,
                           "energy" = DR2TKCAL, "protein" = DR2TPROT) %>%
                    filter(weight != 0) %>%
                    filter_all(all_vars(!is.na(.))) %>%
                    # for data visualization part, we don't standaardize the variables
                    mutate_at(vars(-c("id", "weight")), scale) %>%
                    mutate(survey_day = factor(2))

# Merge all dataset together
Data_final <- New_Day1_dat %>%
                rbind(New_Day2_dat) %>% 
                    inner_join(New_Demo_dat, by = "id") %>%
                        inner_join(New_Diabetes_dat, by = "id") %>%
                            inner_join(New_Insur_dat, by = "id")
dim(Data_final)
```
So after cleaning process, I finally got a data with 13245 observations and 22 variables.

```{r show_data, echo=FALSE}
knitr::kable(Data_final[1:3,1:10], caption = "The head 3 rows and head 10 columns of final data ")
```

---

### Data Visualization
For better understanding the final data we got, we decide to do some visualization jobs, here I am going to plot the difference of average zinc iron and sodium intake amount between diabetes and non-diabetes groups at each level of people.
By ploting these data, we can directly understand the eating habbit's difference in microelements intake of people.  

```{r data_visualize, echo=FALSE}
New_Day1_dat <- Day1_data %>%
                    select("id" = SEQN, "weight" = WTDRD1, "iron" = DR1TIRON,
                           "calcium" = DR1TCALC, "zinc" = DR1TZINC, "sodium" = DR1TSODI,
                           "VE" = DR1TATOC, "VA" = DR1TVARA, "VC" = DR1TVC,
                           "alcohol" = DR1TALCO, "fat" = DR1TTFAT, "fiber" = DR1TFIBE,
                           "sugar" = DR1TSUGR, "carbonhydrate" = DR1TCARB,
                           "energy" = DR1TKCAL, "protein" = DR1TPROT) %>%
                    filter(weight != 0) %>%
                    filter_at(vars(-c("id", "weight")), all_vars(!is.na(.))) %>%
                    # for data visualization part, we don't standaardize the variables
                    #mutate_at(vars(-c("id", "weight")), scale)  %>%
                    mutate(survey_day = factor(1))

# Day2 data
New_Day2_dat <- Day2_data %>%
                    select("id" = SEQN, "weight" = WTDR2D, "iron" = DR2TIRON,
                           "calcium" = DR2TCALC, "zinc" = DR2TZINC, "sodium" = DR2TSODI,
                           "VE" = DR2TATOC, "VA" = DR2TVARA, "VC" = DR2TVC,
                           "alcohol" = DR2TALCO, "fat" = DR2TTFAT, "fiber" = DR2TFIBE,
                           "sugar" = DR2TSUGR, "carbonhydrate" = DR2TCARB,
                           "energy" = DR2TKCAL, "protein" = DR2TPROT) %>%
                    filter(weight != 0) %>%
                    filter_all(all_vars(!is.na(.))) %>%
                    # for data visualization part, we don't standaardize the variables
                    #mutate_at(vars(-c("id", "weight")), scale) %>%
                    mutate(survey_day = factor(2))

# Merge all dataset together
Data_final1 <- New_Day1_dat %>%
                rbind(New_Day2_dat) %>% 
                    inner_join(New_Demo_dat, by = "id") %>%
                        inner_join(New_Diabetes_dat, by = "id") %>%
                            inner_join(New_Insur_dat, by = "id")

## Compare the average microelement intake amount at each age, gender and 
## insurance level between day1 and day2.
data_nodiab <- Data_final1 %>%
    filter(diabetes == 0 & survey_day == 1) %>%
    select(c("weight", "age_group", "gender", "insurance","zinc",
             "iron", "sodium")) %>%
    group_by(age_group, gender, insurance) %>%
    summarise(avg_iron = sum(iron * weight) / sum(weight),
              avg_zinc = sum(zinc * weight) / sum(weight),
              avg_sodium = sum(sodium * weight) / sum(weight))

data_diab <- Data_final1 %>%
    filter(diabetes == 1 & survey_day == 1) %>%
    select(c("weight", "age_group", "gender", "insurance","zinc",
             "iron", "sodium")) %>%
    group_by(age_group, gender, insurance) %>%
    summarise(avg_iron = sum(iron * weight) / sum(weight),
              avg_zinc = sum(zinc * weight) / sum(weight),
              avg_sodium = sum(sodium * weight) / sum(weight))

data_combined <- data_nodiab %>%
    inner_join(data_diab, by = c("age_group", "gender", "insurance"),
               suffix = c("_nodb", "_db")) %>%
    pivot_longer(cols = -c("age_group", "gender", "insurance"),
                 names_to = c(".value", "diabetes"), 
                 names_pattern = "(avg_.*[_$])(db|nodb)") %>%
    mutate(group_id = paste(paste(age_group, substr(gender,1,1),sep = "_"), 
                            insurance, sep = "_"))


fig_zinc <- ggplot(data_combined, aes(x = group_id, y = avg_zinc_, fill = diabetes, 
                                      shape = diabetes, color = diabetes)) +
    geom_bar(position = "dodge", stat = "identity") +
    geom_text(aes(label=round(avg_zinc_,1)), color = "black", 
              position = position_dodge(1), size=4) + coord_polar() +
    labs(y = "zinc amount(mg)", title = "Zinc(mg)", 
         subtitle = "Zinc intake amount(mg) among each group of people")

fig_iron <- ggplot(data_combined, aes(x = group_id, y = avg_iron_, fill = diabetes, 
                                      shape = diabetes, color = diabetes)) +
    geom_bar(position = "dodge", stat = "identity") +
    geom_text(aes(label=round(avg_iron_,1)), color = "black", 
              position = position_dodge(1), size=4) + coord_polar() +
    labs(y = "Iron(mg)", title = "Iron(mg)", 
         subtitle = "Iron intake amount(mg) among each group of people")

fig_sodium <- ggplot(data_combined, aes(x = group_id, y = avg_sodium_, fill = diabetes, 
                                        shape = diabetes, color = diabetes)) +
    geom_bar(position = "dodge", stat = "identity") +
    geom_text(aes(label=round(avg_sodium_)), color = "black", 
              position = position_dodge(1), size=3) + coord_polar() +
    labs(y = "Sodium(mg)", title = "Sodium(mg)", 
         subtitle = "Sodium intake amount(mg) among each group of people")
fig_iron
fig_zinc
fig_sodium
```

So, fron the above 3 graphs, we can see that:  
(1) For the iron intake, we can see there exist some difference between diabetes groups. Especially for the male adults(19-40) who don't have health insurance, the diabetes group would obvious overload iron intakes in their meals.  
(2) For the zinc intake, according to the research paper, zinc can somewhat have beneficial effect on preventing diabetes problem. That can be supported by my plot that for those male teenagers(13-18) with health insurance, the non-diabetes group tend to get more zinc intakes in their meals.  
(3) For the sodium intake, people with more salt intake will tend to have a blood pressure problem and maybe relevant to diabetes problem. So from my plot we can see that for the male teenager group with health insurance, those have diabetes taking more amount of sodium than those without diabetes.

---

### Modeling
we are going to build penalized logistic model for our question. And we implement cross validation methods to get lambda parameter; parallel computing method to improve efficiency; AUC value to evaluate our model performance.
```{r model1, echo=FALSE}
## setup parallel computing parameter
ncores = 2  
# set up a cluster called 'cl'
cl = makeCluster(ncores)
# register the cluster
registerDoParallel(cl)

# set the number of testset partition times
N_test <- 10
# delete the insurance variable and add interactive term with intake variables
times_insur <- function(x) x * Data_final$insurance
Data_final <- select(Data_final, -weight) %>%
    mutate_at(c("iron", "calcium", "zinc", "sodium", "VA", "VC", "VE",
                "alcohol", "fat", "fiber", "sugar", "carbonhydrate",
                "energy", "protein"), times_insur) %>%
    right_join(Data_final, by = c("id", "survey_day", "gender", 
                                  "age_group", "income", "diabetes",
                                  "insurance"), suffix = c("_ins", "_ogn")) %>%
    select(-c("id", "weight", "insurance"))
```

```{r model2}
# get the number of obs
Nnum <- nrow(Data_final)
# the number of obs as test data
test_Num <- round(0.2 * Nnum)
# the number of obs as train and cv data
train_Num <- Nnum - test_Num

# building the model for N_test time in order to avoid overfitting problem
result = foreach(i = 1:N_test) %dopar% {
    library(glmnet)
    library(ROCit)
    # divide data into training set and test set
    set.seed(i)
    test_id <- sample(1:Nnum, test_Num)
    test_data <- Data_final[test_id,]
    train_cv_data <- Data_final[-test_id,]
    
    
    # divide the dependent variables and response in the training set
    x_train <- model.matrix(diabetes ~ ., train_cv_data)[, -1]
    y_train <- train_cv_data$diabetes    
    
    # use cross validation metthod to find the optimal lambda parameter
    cv.lasso <- cv.glmnet(x_train, y_train, alpha = 1, family = "binomial", 
                          type.measure = "auc", parallel = TRUE)
    
    # use the lambda which gives the best AUC value and avoid improving model 
    # complexity to build our model
    model_small <- glmnet(x_train, y_train, alpha = 1, famaily = "binomial", 
                          lambda = cv.lasso$lambda.min)
    
    # store the optimal lambda value
    lambda <- cv.lasso$lambda.min
    
    # make prediction using test data
    x_test <- model.matrix(diabetes ~ ., test_data)[, -1]
    y_test <- test_data$diabetes
    y_hat_small <- predict.glmnet(model_small, newx = x_test, type = "response")
    
    # evaluate model performance on test data using ROC curve and AUC value
    ROC_obj_small <- rocit(score = as.vector(y_hat_small), class = y_test)
    
    # store the AUC value and plot the ROC curve
    # plot(ROC_obj_small)
    AUC <- ROC_obj_small$AUC    
    c(lambda, AUC)
}  

# building final model for all of our data 
result <- matrix(unlist(result), ncol = N_test, nrow = 2)
x_all <- model.matrix(diabetes~., Data_final)[, -1]
y_all <- Data_final$diabetes

# choose the mean value of the optimal lambdas above as the final optimal lambda
# for our final model
lambda_final <- rowMeans(result)[1]
model <- glmnet(x_all, y_all, family = "binomial", alpha = 1, lambda = lambda_final)

# the coefficients of the final model
beta_all <- coef(model)

# estimation of the final model performance using the average AUC value above
AUC_final <- rowMeans(result)[2]
stopCluster(cl)
```

```{r show_result, echo=FALSE}
cat("Estimate model performance by AUC: ", AUC_final, "\n")
beta_all
ROC_obj <- rocit(score = as.vector(predict(model, x_all)), class = y_all)
plot(ROC_obj)
title("ROC curve for the final model on whole data")
```

### Model Interpretation
According to the final model we got above, we only remain 14 variables that are important chosen by lasso method.

And then we can see that:  
(1) For sugar predictor, the coefficients of the original one and the insurance interacted one are both negative, that means if a person has much sugar intake in his/her meal, then it may have less chance to be told that he/she has a diabetes issue.  
(2) For age predictor, the coefficients of the elder people are negative, that means an elder person may be more likely to be told having a diabetes issue.  
(3) For income predictor, people with higher income tend to have less probability to get diabetes issue. That make sense because rich people maybe pay more attention to their health status.  
(4) For insurance interacted term, there are only sugar and sodium interacted remain in the model. And that can answer our main question: 

People with health insurance are **more likely** to have diabetes issue with same amount **sodium, iron, fat** intakes than those without insurance;  
And they are **less likely** to have diabetes issue with same amoount **VC, VE, sugar, alcohol, protein** intakes than those without insurance.



## Python

### Heading 1

### Heading 2

### Heading 3

### Heading 4

### Results


## STATA

### Heading 1

### Heading 2

### Heading 3

### Heading 4

### Results

# Summary

# Discussion

# References
